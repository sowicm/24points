# 24points

A playing card game, draw 4 cards, and use plus, minus, product, divide operations to any sequence of these cards to obtain 24 points.

## old description:

### 24点小游戏

#### 功能分析：

24点小游戏是我们日常生活中的一个纸牌游戏，玩家通过4张1~13（A~K）的牌，用“+”，“-”，“*”，“/”即括号写出一个表达式，使表达式的计算结果等于24，且表达式必须用到玩家所得4张扑克牌的点数，且每个数只能使用一次。
由于功能趋于常规，界面无需华丽，所以我决定用MFC来完成这个项目。并模仿Windows自带的纸牌游戏风格，使游戏界面简洁美观，玩家可以通过随机发放的4张扑克牌，计算结果，并输入计算表达式，系统判断正误。
我们需要实现的如下：

* 界面
  * 菜单 （发牌、指定4张牌、查看所有解，退出）
  * 背景色
  * 扑克牌的图片
  * 编辑框
  * “答题”和“无解”两个按钮
  * 状态栏的计时器
* 逻辑（算法）
  * 随机生成不重复的4张扑克
  * 根据输入的表达式字符串求值
  * 根据给定的4个数算出所有的解
  * 去除所有的解中重复的解
* 额外
  * 统计总局数，胜利局数，胜率，总耗时，平均耗时
  * 输入体验的优化

#### 界面设计

这次我们是先写界面，再写逻辑，利用VC++可视化设计工具，我们很快设计好了如下的界面：

![preview_1](https://github.com/sowicm/24points/raw/master/preview/image001.jpg)

我将背景设置成和Windows XP下纸牌游戏一致的背景色，并从中提取了52张扑克牌的图片用作24点游戏的扑克图片。

#### 逻辑算法

##### 随机生成4张扑克
因为24点游戏中可用的扑克总数是52张，并且一次只有4张，所以我们在文档类中定义了一个 int cards[4]; 用它们的数值（0~51）来分别表示每一张牌。我们每次随机生成一张牌时都判断它与前面的牌是否有重复，一直到没有重复为止。


##### 根据输入的表达式字符串求值
一开始我们打算用逆波兰表达式的方法。但是后来发现直接用压栈的方法更好实现。

算法的伪代码如下：

逐个处理字符串的字符：

    if (is_numerial())
    {
        读入这个数字。
        如果已经超过4个数字，则报错。
        如果数字不是1~13，则报错。
        如果是当前没有的数字，则报错。
        If (符号栈.top() is * or /)
            计算并压入数值栈。
    }
    else if (+/-)
    {
        如果符号栈的栈顶是+或-
        则计算上一个符号并压入数值栈
        符号栈.push(+/-);
    }
    Else if (* or /)
    {
        符号栈.push(* or /);
    }
    Else if (左括号)
    {
        递归处理括号内的表达式；
    }
    Else
    {
        未知符号，报错
    }

算法的时间复杂度是 O(n)


##### 根据给定的4个数算出所有的解

通过枚举4个数的全排列和运算符和优先顺序就可以得到所有的解。我们通过逆序数的方法求全排列，而且只需要在程序中执行一次，将结果存于数组当中供每次使用，这样的方法虽然在本程序中带来不了太多好处，但如果是其他数据更庞大、对执行速度要求高的程序中可能有极大的性能提升。

    C24pointsDoc::C24pointsDoc()
    {   
        A[0][0] = 0;
        A[0][1] = 1;
        A[0][2] = 2;
        A[0][3] = 3;
        int k = 0;
        for (int j = 3; j > 0; --j)
        {
            if (A[k][j] > A[k][j - 1])
            {
                memcpy(A[k + 1], A[k], sizeof(A[0]));
                for (int ii = 3; ii >= j; --ii)
                {
                    if (A[k][ii] > A[k][j - 1])
                    {
                        A[k + 1][j - 1] = A[k][ii];
                        A[k + 1][ii] = A[k][j - 1];
                        break;
                    }
                }
                for (int ii = j; ii < 2 + j / 2; ++ii)
                {
                    swap(A[k + 1][ii], A[k + 1][4 - ii + j - 1]);
                }
                ++k;
                j = 4;
            }
        }
    }

然后枚举运算符和优先顺序得到所有可能的表达式，然后将其通过前面的表达式求值函数算出结果。但我们马上注意到，这样的话会产生相当多重复的答案，比如：3 7 10 4 这4张牌，会出现
3 + 7 + 10 + 4
7 + 3 + 10 + 4
4 + 10 + 3 + 7
等等一系列对人类而言相同的答案，所以我接下来花了大量的时间来设计去除重复答案的算法。

##### 去除所有的解中重复的解

记号:
a, b, c, d 是数字 (1,2,3 等), x, y, z, w 是表达式 如： 1, 1 + 2, (1 + 2 × 6) /5, 等. 
如果两个表达式 x 和 y 等价， 则写做 x ↔ y, 比如： a + b ↔ b + a, a - (b - c) ↔ a + c - b 等. 
如果两个表达式 x 和 y 等价，并且我们给予 y 优先权， 因为y更简约或者更易于人机交互, 则写做 x → y . 比如: a - (b - c) ↔ a + c - b , 不过我们给予后者优先权, 所以我们有 a - (b - c) → a + c - b
± 是 + 或者 -, 同时 ×/ 是 × 或 /.

第一部分: 算数运算的等价关系
这部分都是很基本的等价关系. 1 × 2 × 3 × 4 和 (4 × 3 × ( 2 × 1)) 明显完全一样，不过多数人会喜欢第一种解法，因为解法一比较简洁. 
第一部分的规则可以用一句话概括：把数字换成变量, 如果两个表达式对于任意 整数变量都有一样的值, 那么这两个表达式等价. 例如： 对于组合 {1,2,3,4} 和以下两个表达式: (3 + 2 + 1) × 4 和 4 × (1 + 2 + 3) : , 我们先把 1 换作 a, 2 换作 b, 3 换作 c 同时 4 换作 d, 现在这两个表达式变为 (c + b + a) × d 和 d × ( a + b + c). 对任何的整数组合 {a,b,c,d}， 这两个表达式都有一样的值. 所以我们知道这两个表达式等价. 在 (3 + 2 + 1) × 4 和 4 × (1 + 2 + 3) 中, 我们更喜欢前者因为对某些人机交互系统它更简洁(还记得计算器吗？), 因为输入(3 + 2 + 1) × 4 无需输入括号. 也就是 4 × (1 + 2 + 3) → (3 + 2 + 1) × 4. 一个判断两个等价表达式优先权的通用规则是： 我们把比较复杂的部分放到左边. 
在给出第一部分的具体规则之前， 我们需要最后一个注脚： 对表达式 x 和 y (别忘了 x 可以是 a + b), 当我们写出 x ×/ y, 如果需要的话，我们在 x 或 y 外面加上括号.

(1) 交换律:    x ± y ↔ ± y + x         x × y ↔ y × x         x ×/ y ×/ z ↔ x ×/ z ×/ y 
优先权 1: - 和 / 在最右边, 例如. - a + b → b - a, a / b × c → a × c / b 
优先权 2: 复杂的表达式放在最左边, 例如. c + a × b → a × b + c, a × (b + c) → (b + c) × a ...

(2) 结合律:     x + y ± z ↔ ( x + y ) ± z ↔ x + (y ± z )         x × y ×/ z ↔ ( x × y ) ×/ z ↔ x × (y ×/ z )         ( x / y ) / z ↔ x / y / z 
优先权: 括号比较少的, 比如： (a + b) + c → a + b + c, (a / b) / c → a / b / c .

(3) + 和 - 的交换性, 以及 × 和 / 的交换性:     x - (y - z) ↔ x + z - y         x × z / y	↔ x/(y/z)         x /(y × z)	↔ x/y/z 
优先权: 括号比较少的, 例如. a - (b - c) → a + c - b, a/(c/b) → a × b / c

(4) 减号越少越好:     a - (b - c) ×/ d ↔ a + (c - b) ×/ d, 注意: 这条规则不被规则(3) 包含. 
优先权: 通过规则 (3) 的优先权我们有: a - (b - c) ×/ d → (c - b) ×/ d + a

(5)平局的情况: a × b × c × d 还是 d × c × b × a, (a + b) × (c + d) 还是 (d + c) × (a + b)? 
优先权: 无所谓啦. 我喜欢大的数字在最左边, 也就是： 1 × 2 × 3 × 4 → 4 × 3 × 2 × 1, (1 + 2) × (5 + 3) → (5 + 3) × (2 + 1)

第二部分: 表达式的值是 0 或 1 的特殊情况
(6) 1 的 乘法/除法 :     x × y ↔ x / y, 如果表达式 y 的值是 1.
优先权: x × y, 例如： (13 + 11) / (5 - 4) → (13 + 11) × (5 - 4). 类似的： (12 + 6 × 2) / 1 → (12 + 6 × 2) × 1.

(7) 表达式 × z 的位置， 当 z 的值是 1 的时候: 如果 z = 1, 我们有: x + y × z ↔ x × z + y ↔ (x + y ) × z 
优先权: (x + y ) × z 因为其对称性

(8) 特别的组合 {a, b, c, c} : a × b × c /c ↔ a × b + c - c, 以及 ( a + b ) × c /c ↔ a + b + c - c .
优先权: a × b + c - c 或者 a + b + c - c

(8.b) 最后的组合 {a, b, 1, 1} : a × b × 1 × 1 ↔ a × b + 1 - 1, 以及 ( a + b ) × 1 × 1 ↔ a + b + 1 - 1 .
优先权: a × b + 1 - 1 或者 a + b + 1 - 1

(8.c) 游戏中有 24的情况 : 这种情况只有当你玩大游戏时，有24这种大的数字存在才有意义. 
24 × x / y → 24 + x - y, 这里 x 和 y 是两个有同样值的表达式
24 + a - b - c → 24 + b + c - a
24 + c - x 比 x + 24 - c 有优先级， 这里 x 是一个有两个数字的表达式, 当然 c 和 x 有同样的值. 
这三条看起来很随意的规则减少了许多多余的解法当24在游戏之中。

最后我们把所有的4张牌的组合的所有的去重复解打了一张表存于程序中（40k+)，直接通过查表给出所有去重复可行解。至此逻辑算法部分已经全部完成，我好不容易松了口气。

#### 额外的部分

我们统计了玩家的总局数，胜利局数，胜率，和总耗时，平均耗时，并将数据存放在了AppData\Roaming\24points\save.dat 里面，提高了游戏的乐趣。

![preview_3](https://github.com/sowicm/24points/raw/master/preview/image003.png)

我们在自己测试的过程中发现经常会输入出中文的符号，比如（）而不是()，也容易输入x而不是*，甚至会输入＋－×÷这样的全形符号，与其告诉用户该怎么输入，不如我们直接处理增加用户体验。所以我们的程序就能处理这样的表达式了：

![preview_4](https://github.com/sowicm/24points/raw/master/preview/image004.png)
